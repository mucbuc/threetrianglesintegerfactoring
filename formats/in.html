<html>
<head>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
<header>
<b>Category: math.NT</b>
<hr>
<br>
<h1> Three Triangles Integer Factorization Algorithm </h1>
</header>

This is my discovery of an algorithm for integer factorization. To my knowledge it is not based on any existing solutions. I do not claim it to be efficient or useful, I'm only concerned with its correctness and completeness. 

<h2>Abstract</h2>
Factor the composite number <em>C=(a+1)*(a+b)</em> by finding the solution to <em>C=T(a)+T(a+b)-T(b-1)</em> where <em>T(n)</em> generates the nth triangular number.

<h2>Definitions</h2>
	<ul>
		<li><b>a, b := natural numbers
		<li><b>T(n)</b> := n*(n+1)/2</li>
		<li><b>S(a, b)</b> := T(a)+T(a+b)-T(b-1)</li>
		<li><b>make_even(n)</b> := if n is odd return n-1 else return n</li>
	</ul>

<h2>Proof of <em>(a+1)*(a+b)=T(a)+T(a+b)-T(b-1)</em></h2>
<ol>
<li><em>(a+1)*(a+b)=T(a)+T(a+b)-T(b-1)</em></li>
<li><em>a*a+a*b+a+b=a*(a+1)/2+(a+b)*(a+b+1)/2-(b-1)*b/2</em></li>
<li><em>2*a*a+2*a*b+2*a+2*b=a*(a+1)+(a+b)*(a+b+1)-(b-1)*b</em></li>
<li><em>2*a*a+2*a*b+2*a+2*b=a*a+a+a*(a+b+1)+b*(a+b+1)-b*b+b</em></li>
<li><em>2*a*a+2*a*b+2*a+2*b=a*a+a+a*a+a*b+a+b*a+b*b+b-b*b+b</em></li>
<li><em>2*a*a+2*a*b+2*a+2*b=2*a*a+2*a*b+2*a+2*b</em></li>
<li><em>0=0</em></li>
</ol>

<h2>Proof that <em>S(a, b) > S(a-2, b+2)</em></h2>
This is required to show that the algorithm makes progress on step 3. 
<ol>
<li><em>S(a, b) > S(a-2, b+2)</em></li>
<li><em>(a+1)*(a+b) > (a+1-2)*(a+b-2+2)</em></li>
<li><em>a*a+a+b > (a-1)*(a+b)</em></li>
<li><em>a*a+a+b > a*a-(a+b)</em></li>
<li><em>a+b > -(a+b)</em></li>
<li><em>1*(a+b) > -1*(a+b)</em></li>
<li>Since a, b > 0 => <em>1 > -1</em></li>
</ol>

<h2>Proof that <em>S(a, b) < S(a, b+max(1, ceil((C-S(a, b))/(a+1))))</em></h2>
This is required to show that the algorithm makes progress on step 4. 
<ol>
<li><em>S(a, b) < S(a, b+max(1, ceil((C-S(a, b))/(a+1))))</em></li>
<li><em>(a+1)*(a+b) < (a+1)*(a+b+max(1, ceil((C-S(a, b))/(a+1))))</em></li>
<li><em>a+b < a+b+max(1, ceil((C-S(a, b))/(a+1)))</em></li>
<li><em>0 < max(1, ceil((C - S(a, b))/(a+1)))</em></li>
<li><em>0 < 1</em></li>
</ol>

<h2>Algorithm</h2>
	<em>input:</em> C => integer greater than 2 
	<br>
	<em>output:</em> found factors, or 1 and C if C is a prime number
	<ol>
		<li> let a = make_even( floor( sqrt( C ) ) - 1 )</li>
		<li> let b = 1</li>
		<li> if <em>S(a, b) > C</em> then <em>a = a - 2, b = b + 2</em></li>
		<li> if <em>S(a, b) < C</em> then <em>b = b + max(1, ceil((C - S(a, b)) / (a + 1)))</em></li>
		<li> if <em>S(a, b) == C</em> then exit: found factors <em>(a + 1)</em> and <em>(a + b)</em>
		<li> if <em>a == 0</em> then exit: <em>C</em> is a prime number
		<li> goto step 3.</li>
	</ol>
<h2> Examples </h2>
<h3>Factor 51</h3>
<ol> 
<li> a = 6, b = 1 
	<br> S(6, 1) = 49
	<br> => b = b + max(1, ceil(2 / 7)) 
</li>
<li> a = 6, b = 2 
	<br> S(6, 2) = 56 
	<br> => a = a - 2, b = b + 2 
</li>
<li> a = 4, b = 4
	<br> S(4, 4) = 40 
	<br> => b = b + max(1, ceil(11 / 5)) 
</li>
<li> a = 4, b = 7
	<br> S(4, 7) = 55 
	<br> => a = a - 2, b = b + 2 
</li>
<li> a = 2, b = 9
	<br> S(2, 9) = 33 
	<br> => b = b + max(1, ceil(18 / 3)) 
</li>
<li> a = 2, b = 15
	<br> S(2, 15) = 51
	<br> => 51 = 3 * 17 
</li>
</ol>

<h3>Factor 23</h3>
<ol>
<li> a = 2, b = 1
	<br> S(2, 1) = 9 
	<br> => b = b + max(1, ceil(14 / 3)) 
</li>
<li> a = 2, b = 6
	<br> S(2, 6) = 24 
	<br> => a = a - 2, b = b + 2 
</li>
<li> a = 0, b = 8 
	 <br> => 23 = 1 * 23 
</li>
</ol>
<h3>Conclusion</h3>
Instead of focusing on performance of factorization this algorithm tries to explore a new solution. One potential benefit I see is the reduced magnitude of dividends used in divisions. Hope it inspires some ideas.   
</body>
</html>
