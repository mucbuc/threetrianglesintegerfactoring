<html>
<body>
<header>
<h1> Three Triangles Integer Factorization Algorithm </h1>
</header>

<h2>Abstract:</h2>
Factor the composite number <em>C=(a+1)(a+b)</em> by finding the solution to <em>C=T(a)+T(a+b)-T(b-1)</em> where <em>T(n)</em> generates the nth triangular number.

<h2>Definitions:</h2>
	<ul>
		<li>a, b := natural numbers
		<li>T(n)</b> := n(n+1)/2</li>
		<li>S(a, b)</b> := T(a)+T(a+b)-T(b-1)</li>
		<li>make_even(n)</b> := if n is odd return n-1 else return n</li>
	</ul>

<h2>Theorem:</h2>
For every composite number <em>C=(a+1)(a+b)</em> there exist three triangular numbers such that <em>C=T(a)+T(a+b)-T(b-1)</em>.

<h2>Proof:</h2>
<ol>
<li><em>(a+1)(a+b)=T(a)+T(a+b)-T(b-1)</em></li>
<li><em>a<sup>2</sup>+ab+a+b=a(a+1)/2+(a+b)(a+b+1)/2-(b-1)b/2</em></li>
<li><em>2a<sup>2</sup>+2ab+2a+2b=a(a+1)+(a+b)(a+b+1)-(b-1)b</em></li>
<li><em>2a<sup>2</sup>+2ab+2a+2b=a<sup>2</sup>+a+a(a+b+1)+b(a+b+1)-b<sup>2</sup>+b</em></li>
<li><em>2a<sup>2</sup>+2ab+2a+2b=a<sup>2</sup>+a+a<sup>2</sup>+ab+a+ba+b<sup>2</sup>+b-b<sup>2</sup>+b</em></li>
<li><em>2a<sup>2</sup>+2ab+2a+2b=2a<sup>2</sup>+2ab+2a+2b</em></li>
<li><em>0=0</em></li>
</ol>

<h2>Theorem:</h2>
For every natural number <em>a >= 2</em> and <em>b > 1</em> it holds that <em>S(a, b) > S(a-2, b+2)</em>.

<h2>Proof:</h2>
<ol>
<li><em>S(a, b) > S(a-2, b+2)</em></li>
<li><em>(a+1)(a+b) > (a+1-2)(a-2+b+2)</em></li>
<li><em>a<sup>2</sup>+a+b > (a-1)(a+b)</em></li>
<li><em>a<sup>2</sup>+a+b > a<sup>2</sup>-(a+b)</em></li>
<li><em>a+b > -(a+b)</em></li>
<li><em>1 > -1</em>(<em>a+b</em> > 0 since <em>a >= 2</em> and <em>b > 1</em>)</li>
</ol>


<h2>Theorem:</h2>
For every natural number <em>a, b > 0</em> it holds that <em>S(a, b) < S(a, b+max(1, ceil((C-S(a, b))/(a+1))))</em>.

<h2>Proof:</h2>
<ol>
<li><em>S(a, b) < S(a, b+max(1, ceil((C-S(a, b))/(a+1))))</em></li>
<li><em>(a+1)(a+b) < (a+1)(a+b+max(1, ceil((C-S(a, b))/(a+1))))</em></li>
<li><em>a+b < a+b+max(1, ceil((C-S(a, b))/(a+1)))</em></li>
<li><em>0 < max(1, ceil((C - S(a, b))/(a+1)))</em></li>
<li><em>0 < 1</em></li>
</ol>

<h2>Algorithm:</h2>
	<em>input:</em> C => integer greater than 2 
	<br>
	<em>output:</em> found factors, or 1 and C if C is a prime number
	<ol>
		<li> let a = make_even( floor( sqrt( C ) ) - 1 )</li>
		<li> let b = 1</li>
		<li> if <em>S(a, b) > C</em> then <em>a = a - 2, b = b + 2</em></li>
		<li> if <em>S(a, b) < C</em> then <em>b = b + max(1, ceil((C - S(a, b)) / (a + 1)))</em></li>
		<li> if <em>S(a, b) == C</em> then exit: found factors <em>(a + 1)</em> and <em>(a + b)</em>
		<li> if <em>a == 0</em> then exit: <em>C</em> is a prime number
		<li> goto step 3.</li>
	</ol>
<h2> Examples </h2>
<h3>Factor 51</h3>
<ol> 
<li> a = 6, b = 1 
	<br> S(6, 1) = 49
	<br> => b = b + max(1, ceil(2 / 7)) 
</li>
<li> a = 6, b = 2 
	<br> S(6, 2) = 56 
	<br> => a = a - 2, b = b + 2 
</li>
<li> a = 4, b = 4
	<br> S(4, 4) = 40 
	<br> => b = b + max(1, ceil(11 / 5)) 
</li>
<li> a = 4, b = 7
	<br> S(4, 7) = 55 
	<br> => a = a - 2, b = b + 2 
</li>
<li> a = 2, b = 9
	<br> S(2, 9) = 33 
	<br> => b = b + max(1, ceil(18 / 3)) 
</li>
<li> a = 2, b = 15
	<br> S(2, 15) = 51
	<br> => 51 = 3 * 17 
</li>
</ol>

<h3>Factor 23</h3>
<ol>
<li> a = 2, b = 1
	<br> S(2, 1) = 9 
	<br> => b = b + max(1, ceil(14 / 3)) 
</li>
<li> a = 2, b = 6
	<br> S(2, 6) = 24 
	<br> => a = a - 2, b = b + 2 
</li>
<li> a = 0, b = 8 
	 <br> => 23 = 1 * 23 
</li>
</ol>
<h3>Conclusion</h3>
To my knowledge this is not based on any existing solutions. I do not claim it to be efficient or useful, I'm only concerned with its correctness and completeness. One potential benefit I see is the reduced magnitude of dividends used in divisions. Hope it inspires some ideas.   
</body>
</html>
